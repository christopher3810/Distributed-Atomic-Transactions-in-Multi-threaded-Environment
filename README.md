분산 처리 환경에서 트랜잭션의 atomic 성을 보장하려면 좀 더 복잡한 전략과 도구가 필요함. 

분산 트랜잭션을 처리하기 위한 여러 전략 및 패턴이 존재함 

Two-Phase Commit, Saga Pattern 등

각 시나리오별로 분산 트랜잭션 문제와 해결 방법에 대해 구현 및 테스트 진행

## 시나리오

---

### 결제 상황

>**Note**
> 동일한 사용자 정보로 Request 가 들어 왔을시 Request 처리는 하나만 처리되어야 함.

이후 되고 나면

>**Note**
> 하나의 서비스에서 결제를 처리하고 다른 서비스에서 주문을 생성하는 시나리오에서 결제는 성공했지만 주문 생성에 실패하는 문제. \
>오류 발생 시 보상 트랜잭션을 실행되어야 함.

>**Note**
> 특정 상황에 대한 기능적 구현 및 시나리오 상의 문제 해결을 위한 임의이 시나리오를 채택. \
> 일반적인 시나리오라고 가정.


### 문제 해결 방법

1. Saga Pattern

각 서비스가 로컬 트랜잭션만을 사용하게 하고, 비즈니스 로직의 일관성을 유지하기 위해 보상 트랜잭션을 실행

서비스 간에 강한 결합이 없으므로 확장성이 높음. 시스템 전체가 블로킹되지 않아 성능이 좋음.

보상 트랜잭션 로직을 구현해야 하며. 롤백이 항상 가능한 상태를 보장하기 어려울 수 있음.

2. Event-driven Architecture
   
서비스가 이벤트를 발행하고 다른 서비스가 이벤트를 구독하여 반응하는 아키텍처.

시스템 간의 강한 결합이 줄어들고 확장성이 높아짐.

비동기 처리로 인해 성능이 향상.

이벤트 처리 순서와 보장성에 대한 추가 로직이 필요할 수 있음.

3. Distributed Locking

분산 환경에서 여러 서비스가 동일한 리소스에 동시에 액세스하지 않도록 하는 잠금.

쉽게 구현할 수 있으며, 동시성 문제를 효과적으로 해결할 수 있음.

데드락 발생 가능성이 있으며, 확장성에 제한이 있을 수 있음.
